import { Duration } from "luxon";
import useAudioRecorder from "@/hooks/useAudioRecorder";
import { AudioRecorderButton } from "@/components/audio-recorder-hook/audio-recorder-button";
import { AudioRecorderVisualizer } from "@/components/audio-recorder-hook/audio-recorder-visualizer";
import AppContainer from "@/components/app-container";
import Link from "next/link";

<AppContainer maxWidth="sm"><div className="docs-page">

üìì <Link href={"/docs"} as={"/docs"}>Back to overview</Link>

-----

# Recording Audio with React

After wrapping up a simple page to listen to a collection of audio (using the easy-to-use lib [ReactPlayer](https://github.com/CookPete/react-player)), the time came to add some audio recording capabilities to the app. How hard could it be?

Well, quite hard and v√©ry frustrating, as Chrome, Safari and Firefox all have slightly inconsistent Audio API's and recording behavior.

Time for two small demo's of the end result:

## A simple record button

export const AudioRecorderButtonWithState = () => {
    const {
    isRecording,
    isRequestingAccess,
    startRecording,
    stopRecording,
    dataBlobs,
    dataSeconds,
    clearData
  } = useAudioRecorder();
  return (
      <div style={{display: "flex", flexDirection:"column", alignItems: "center", padding: 32}}>
        <AudioRecorderButton
            onStartRecording={() => {clearData(); startRecording()}}
            onStopRecording={stopRecording}
            isRecording={isRecording}
            isRequestingAccess={isRequestingAccess}
        />
        <div style={{margin: 16}}>
            {Duration.fromObject({
                seconds: dataSeconds,
            }).toFormat("mm:ss")}
        </div>
        {dataBlobs.length === 0 && ( <code>Yes, you can press that button üëÜ</code>)}
        {dataBlobs.length === 1 && ( <audio src={URL.createObjectURL(dataBlobs[0])} controls></audio>)}
        {dataBlobs.length === 1 && ( <button onClick={clearData}>Clear recording</button>)}
    </div>
  )
}

<AudioRecorderButtonWithState />

This design might look slightly familiar, as it's a reimplementation from the [Apple Voice Memos app](https://support.apple.com/en-us/HT206775).

The button component is completely decoupled from the recording logic and only needs to be provided with 4 simple props. Internally it can be in 3 different states (idle, recording and requestingAccess), each with their own visual representation.

```tsx
interface Props {
  isRecording: boolean;
  isRequestingAccess: boolean;
  onStartRecording: () => void;
  onStopRecording: () => void;
}

<AudioRecorderButton
    onStartRecording={startRecording}
    onStopRecording={stopRecording}
    isRecording={isRecording}
    isRequestingAccess={isRequestingAccess}
/>
```
<sub>

Source: [audio-recorder-button.tsx](https://github.com/jasperhartong/pod/blob/master/src/components/audio-recorder-hook/audio-recorder-button.tsx)

</sub>

#### Main Takeaways

* The `AudioRecorderButton` is based on the `ButtonBase` of the [Material-UI](https://material-ui.com) framework. This ensures it correctly handles the easily overlooked basics of a button (e.g. focusability, accesability). This is stuff that I don't try to built completely from scratch, as it's easy to get wrong.
* The styling of the three different states is based by only changing a single className on the root of the component. This keeps the component clean, but does require some magic syntax in CSS-in-JS.

## A React component for visualizing incoming recordings


```tsx
<AudioRecorderVisualizer
    uniqueId="demo"
    getFrequencyData={getFrequencyData}
/>
```


export const AudioRecorderVisualizerWithState = () => {
  const { getFrequencyData, startListening, stopListening, isListening } = useAudioRecorder();
  return (
    <div style={{display: "flex", flexDirection:"column", alignItems: "center", padding: 16}}> 
      { isListening && <>
        <AudioRecorderVisualizer
          uniqueId="demo"
          getFrequencyData={getFrequencyData}
        />
        <p>Make some noise now! üòÅ</p>
        </>
      }
    
      
    {isListening
        ? <button onClick={stopListening}>Stop listening and hide visualizer</button>
        : <button onClick={startListening}>Start listening and show visualizer</button>}
    </div>
  );
}

<AudioRecorderVisualizerWithState />

## Implementation details

### A React Hook abstracting away audio recording controls

```tsx
const {
    isListening,
    isRecording,
    isRequestingAccess,
    startListening,
    stopListening,
    startRecording,
    stopRecording,
    getFrequencyData,
    dataBlobs,
    dataSize,
    dataSeconds,
    clearData,
    error,
  } = useAudioRecorder();
```

### ‚ö†Ô∏è MediaRecorder required a polyfill

* The API of `window.MediaRecorder` is not implemented consistent accross browsers, so it's best to use the `audio-recorder-polyfill`.
* I't also smart to rely on a polyfilled MP3 encoder, this also eases uploading and listening back the recording afterwards.

```js
import AudioRecorder from "audio-recorder-polyfill";
import mpegEncoder from "audio-recorder-polyfill/mpeg-encoder";

AudioRecorder.encoder = mpegEncoder;
AudioRecorder.prototype.mimeType = "audio/mpeg";
window.MediaRecorder = AudioRecorder;
```

* **Next.js specific**: save the above polyfill declaration into a file, e.g. `./src/client-polyfills.js` and load it within the `next.config.js`:

```js
module.exports = {
  webpack: function (cfg) {
    const originalEntry = cfg.entry;
    cfg.entry = async () => {
      const entries = await originalEntry();
      // Add client polyfills
      if (
        entries["main.js"] &&
        !entries["main.js"].includes("./src/client-polyfills.js")
      ) {
        entries["main.js"].unshift("./src/client-polyfills.js");
      }

      return entries;
    };

    return cfg;
  },
};
```

### ‚ö†Ô∏è AudioContext required standardization

* AudioContext is also not consistently implemented, so `useAudioRecorder` uses `standardized-audio-context`.

```ts
import {
  AudioContext,
  IAudioContext,
  IMediaStreamAudioSourceNode,
} from "standardized-audio-context";
```

</div></AppContainer>